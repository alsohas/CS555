import os
import warnings
import numpy as np
import pandas as pd
import pickle
import dill
import random
from sklearn.naive_bayes import MultinomialNB
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import AdaBoostClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.preprocessing import StandardScaler
import keras
from keras.models import Sequential
from keras.layers import Dense
from sklearn.metrics import accuracy_score, roc_curve, auc
import matplotlib.pyplot as plt
from sklearn import preprocessing
import seaborn as sns
from keras.optimizers import SGD
# from xgboost import XGBClassifier
from sklearn.decomposition import PCA
import tensorflow as tf
warnings.filterwarnings("ignore")
warnings.simplefilter(action='ignore', category=FutureWarning)

# os.environ['CUDA_VISIBLE_DEVICES'] = '-1'
# Donot modify the method signatures and return dtypes
# you can include additional functions of your choice

class MalwareDetectionModel:

    def __init__(self):
        self.dtypes = {
            'MachineIdentifier': 'category',
            'ProductName': 'category',
            'EngineVersion': 'category',
            'AppVersion': 'category',
            'AvSigVersion': 'category',
            'IsBeta': 'int8',
            'RtpStateBitfield': 'float16',
            'IsSxsPassiveMode': 'int8',
            'DefaultBrowsersIdentifier': 'float32',  # was 'float16'
            'AVProductStatesIdentifier': 'float32',
            'AVProductsInstalled': 'float16',
            'AVProductsEnabled': 'float16',
            'HasTpm': 'int8',
            'CountryIdentifier': 'int16',
            'CityIdentifier': 'float32',
            'OrganizationIdentifier': 'float16',
            'GeoNameIdentifier': 'float16',
            'LocaleEnglishNameIdentifier': 'int16',  # was 'int8'
            'Platform': 'category',
            'Processor': 'category',
            'OsVer': 'category',
            'OsBuild': 'int16',
            'OsSuite': 'int16',
            'OsPlatformSubRelease': 'category',
            'OsBuildLab': 'category',
            'SkuEdition': 'category',
            'IsProtected': 'float16',
            'AutoSampleOptIn': 'int8',
            'PuaMode': 'category',
            'SMode': 'float16',
            'IeVerIdentifier': 'float16',
            'SmartScreen': 'category',
            'Firewall': 'float16',
            'UacLuaenable': 'float64',  # was 'float32'
            'Census_MDC2FormFactor': 'category',
            'Census_DeviceFamily': 'category',
            'Census_OEMNameIdentifier': 'float32',  # was 'float16'
            'Census_OEMModelIdentifier': 'float32',
            'Census_ProcessorCoreCount': 'float16',
            'Census_ProcessorManufacturerIdentifier': 'float16',
            'Census_ProcessorModelIdentifier': 'float32',  # was 'float16'
            'Census_ProcessorClass': 'category',
            'Census_PrimaryDiskTotalCapacity': 'float64',  # was 'float32'
            'Census_PrimaryDiskTypeName': 'category',
            'Census_SystemVolumeTotalCapacity': 'float64',  # was 'float32'
            'Census_HasOpticalDiskDrive': 'int8',
            'Census_TotalPhysicalRAM': 'float32',
            'Census_ChassisTypeName': 'category',
            'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'float32',  # was 'float16'
            'Census_InternalPrimaryDisplayResolutionHorizontal': 'float32',  # was 'float16'
            'Census_InternalPrimaryDisplayResolutionVertical': 'float32',  # was 'float16'
            'Census_PowerPlatformRoleName': 'category',
            'Census_InternalBatteryType': 'category',
            'Census_InternalBatteryNumberOfCharges': 'float64',  # was 'float32'
            'Census_OSVersion': 'category',
            'Census_OSArchitecture': 'category',
            'Census_OSBranch': 'category',
            'Census_OSBuildNumber': 'int16',
            'Census_OSBuildRevision': 'int32',
            'Census_OSEdition': 'category',
            'Census_OSSkuName': 'category',
            'Census_OSInstallTypeName': 'category',
            'Census_OSInstallLanguageIdentifier': 'float16',
            'Census_OSUILocaleIdentifier': 'int16',
            'Census_OSWUAutoUpdateOptionsName': 'category',
            'Census_IsPortableOperatingSystem': 'int8',
            'Census_GenuineStateName': 'category',
            'Census_ActivationChannel': 'category',
            'Census_IsFlightingInternal': 'float16',
            'Census_IsFlightsDisabled': 'float16',
            'Census_FlightRing': 'category',
            'Census_ThresholdOptIn': 'float16',
            'Census_FirmwareManufacturerIdentifier': 'float16',
            'Census_FirmwareVersionIdentifier': 'float32',
            'Census_IsSecureBootEnabled': 'int8',
            'Census_IsWIMBootEnabled': 'float16',
            'Census_IsVirtualDevice': 'float16',
            'Census_IsTouchEnabled': 'int8',
            'Census_IsPenCapable': 'int8',
            'Census_IsAlwaysOnAlwaysConnectedCapable': 'float16',
            'Wdft_IsGamer': 'float16',
            'Wdft_RegionIdentifier': 'float16',
            'HasDetections': 'int8',
        }
        self.file_name = "malware_train.csv"
        self.scaler = StandardScaler()
        self.remove_cols = []

    def clean(self, test_data):
        test_data.drop(columns=self.remove_cols, inplace=True)
        test_data.drop(columns=self.corr_cols, inplace=True)
        # clean up NaN values
        for column in test_data.columns:
            test_data[column].fillna(test_data[column].mode()[0], inplace=True)

        # encode string values
        for col in self.cat_cols:
            test_data[col] = self.le.fit_transform(test_data[col])
        return test_data

    def _clean(self, df):
        # determine skewedness
        skew = pd.DataFrame(
            [{'column': c, 'uniq': df[c].nunique(), 'skew': df[c].value_counts(normalize=True).values[0] * 100} for c in
             df.columns])
        skew = skew.sort_values('skew', ascending=False)
        self.remove_cols.extend(skew[(skew['skew'] > 90)].column.tolist())

        # determine null columns
        total = df.isnull().sum().sort_values(ascending=False)
        percent = (df.isnull().sum() / df.isnull().count()
                   * 100).sort_values(ascending=False)
        null_cols = pd.concat([total, percent], axis=1,
                              keys=['Total', 'Percent'])
        self.remove_cols.extend(null_cols[(null_cols['Percent'] > 5)].index.tolist())
        self.remove_cols.append('MachineIdentifier')
        df.drop(columns=self.remove_cols, inplace=True)

        # Remove correlated columns
        corr_matrix = df.corr().abs()
        upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))
        self.corr_cols = []
        self.corr_cols.extend([column for column in upper.columns if any(upper[column] > 0.70)])

        print(self.corr_cols)
        df.drop(columns=self.corr_cols, inplace=True)

        # clean up NaN values
        for column in df.columns:
            df[column].fillna(df[column].mode()[0], inplace=True)

        # encode string values
        self.le = LabelEncoder()
        self.cat_cols = df.select_dtypes(['category']).columns.tolist()
        for col in self.cat_cols:
            df[col] = self.le.fit_transform(df[col])
        #         df = pd.get_dummies(df,columns=self.cat_cols,drop_first=True)

        return df

        # trains a model, you can access the malware_train.csv file for training your model

    def train(self):
        # read in csv into dataframe
        df = pd.read_csv(self.file_name, dtype=self.dtypes)
        df = self._clean(df)

        # prediction column
        y_train = df['HasDetections']
        # feature columns
        x_train = df.drop('HasDetections', 1)
        x_train[x_train.columns] = self.scaler.fit_transform(x_train[x_train.columns])

        # Principal Component Analysis
        #         pca = PCA(n_components = None)
        #         x_train[x_train.columns] = pca.fit_transform(x_train[x_train.columns])
        #         explained_variance = pca.explained_variance_ratio_
        #         print(explained_variance)
        # self.pca(x_train, y_train)

        # training
        # self.clf = RandomForestClassifier(max_depth=25, n_jobs=100)
        # self.clf = AdaBoostClassifier()
        #         self.clf = GradientBoostingClassifier()
        #         self.clf = XGBClassifier()
        #         self.clf.fit(x_train, y_train)


        self.clf = Sequential()
        sgd = SGD(lr=0.003, decay=0.006, momentum=1, nesterov=False) 
        # 80#################################
        # # Adding the input layer and the first hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu', input_dim=len(x_train.columns)))
        # # Adding the second hidden layer
        # self.clf.add(Dense(output_dim=20, init='uniform', activation='relu'))
        # # fourth hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu'))
        
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu'))
        # # fifth hidden layer
        # self.clf.add(Dense(output_dim=15, init='uniform', activation='softmax'))
        # # Adding the output layer
        # self.clf.add(Dense(output_dim=1, init='uniform', activation='sigmoid'))
        # # Compiling Neural Network
        # self.clf.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

        # 80#################################
        # Adding the input layer and the first hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu', input_dim=len(x_train.columns)))
        # # Adding the second hidden layer
        # self.clf.add(Dense(output_dim=20, init='uniform', activation='tanh'))
        # # fourth hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu'))
        
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='tanh'))
        # # fifth hidden layer
        # self.clf.add(Dense(output_dim=15, init='uniform', activation='softmax'))
        # # Adding the output layer
        # self.clf.add(Dense(output_dim=1, init='uniform', activation='sigmoid'))
        # # Compiling Neural Network
        # self.clf.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

        # 25###################################
        # Adding the input layer and the first hidden layer
        self.clf.add(Dense(output_dim=20, init='uniform', activation='relu', input_dim=len(x_train.columns)))
        # Adding the second hidden layer
        self.clf.add(Dense(output_dim=10, init='normal', activation='relu'))
        # Adding the output layer
        self.clf.add(Dense(output_dim=1, activation='sigmoid', kernel_initializer='normal'))
        # Compiling Neural Network
        self.clf.compile(optimizer=sgd, loss='mse', metrics=['accuracy'])

        # Fitting our model
        history = self.clf.fit(x_train, y_train, validation_split=0.3, batch_size=1000, nb_epoch=500)
        # plot acuracy
        plt.plot(history.history['acc'])
        plt.plot(history.history['val_acc'])
        plt.title('model accuracy')
        plt.ylabel('accuracy')
        plt.xlabel('epoch')
        plt.legend(['train', 'test'], loc='upper left')
        plt.show()

        # plot loss
        plt.plot(history.history['loss'])
        plt.plot(history.history['val_loss'])
        plt.ylabel('loss')
        plt.xlabel('epoch')
        plt.legend(['train', 'test'], loc='upper left')
        plt.show()        
        print('Training finished.')

    #         scores = cross_val_score(self.clf, x_train, y_train, cv=10, n_jobs=-1,scoring='accuracy')
    #         print(scores.mean())

    #         scores = cross_val_score(self.clf, x_train, y_train, cv=10, n_jobs=-1)
    #         print(scores.mean())

    # predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
    # This function must return the predicted probabilities for the test machines
    def predict_probablities(self, test_data):
        print('Predict malware')
        test_data = self.clean(test_data)
        test_data[test_data.columns] = self.scaler.fit_transform(test_data[test_data.columns])
        predictions = self.clf.predict(test_data)
        return predictions


# calls the train function and saves the model_file
# # donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel_100_small.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()

# dm = MalwareDetectionModel()