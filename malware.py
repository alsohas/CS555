import warnings
import numpy as np
import pandas as pd
import pickle
import dill
import random
from sklearn.naive_bayes import MultinomialNB, BernoulliNB, GaussianNB
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import LabelEncoder
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, AdaBoostClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsClassifier
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
from keras.models import Sequential
from keras.layers import Dense
# Donot modify the method signatures and return dtypes
# you can include additional functions of your choice

# bernoulliNB = .58, 0.6 w/ scaler
# randomForest = .54, 0.6 w/ scaler
# adaBoost = .56, 0.62 w/ scaler
# gaussianNB = .5, 0.6 w/ scaler
# decisionTree = .53
# QuadraticDiscriminantAnalysis = 0.58, 0.61 w/ scaler
# gradientBoost = 0.62 w/ scaler


class MalwareDetectionModel:

    def __init__(self):
        self.dtypes = {
            'MachineIdentifier':                                    'category',
            'ProductName':                                          'category',
            'EngineVersion':                                        'category',
            'AppVersion':                                           'category',
            'AvSigVersion':                                         'category',
            'IsBeta':                                               'int8',
            'RtpStateBitfield':                                     'float16',
            'IsSxsPassiveMode':                                     'int8',
            'DefaultBrowsersIdentifier':                            'float32',  # was 'float16'
            'AVProductStatesIdentifier':                            'float32',
            'AVProductsInstalled':                                  'float16',
            'AVProductsEnabled':                                    'float16',
            'HasTpm':                                               'int8',
            'CountryIdentifier':                                    'int16',
            'CityIdentifier':                                       'float32',
            'OrganizationIdentifier':                               'float16',
            'GeoNameIdentifier':                                    'float16',
            'LocaleEnglishNameIdentifier':                          'int16',  # was 'int8'
            'Platform':                                             'category',
            'Processor':                                            'category',
            'OsVer':                                                'category',
            'OsBuild':                                              'int16',
            'OsSuite':                                              'int16',
            'OsPlatformSubRelease':                                 'category',
            'OsBuildLab':                                           'category',
            'SkuEdition':                                           'category',
            'IsProtected':                                          'float16',
            'AutoSampleOptIn':                                      'int8',
            'PuaMode':                                              'category',
            'SMode':                                                'float16',
            'IeVerIdentifier':                                      'float16',
            'SmartScreen':                                          'category',
            'Firewall':                                             'float16',
            'UacLuaenable':                                         'float64',  # was 'float32'
            'Census_MDC2FormFactor':                                'category',
            'Census_DeviceFamily':                                  'category',
            'Census_OEMNameIdentifier':                             'float32',  # was 'float16'
            'Census_OEMModelIdentifier':                            'float32',
            'Census_ProcessorCoreCount':                            'float16',
            'Census_ProcessorManufacturerIdentifier':               'float16',
            'Census_ProcessorModelIdentifier':                      'float32',  # was 'float16'
            'Census_ProcessorClass':                                'category',
            'Census_PrimaryDiskTotalCapacity':                      'float64',  # was 'float32'
            'Census_PrimaryDiskTypeName':                           'category',
            'Census_SystemVolumeTotalCapacity':                     'float64',  # was 'float32'
            'Census_HasOpticalDiskDrive':                           'int8',
            'Census_TotalPhysicalRAM':                              'float32',
            'Census_ChassisTypeName':                               'category',
            'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float32',  # was 'float16'
            'Census_InternalPrimaryDisplayResolutionHorizontal':    'float32',  # was 'float16'
            'Census_InternalPrimaryDisplayResolutionVertical':      'float32',  # was 'float16'
            'Census_PowerPlatformRoleName':                         'category',
            'Census_InternalBatteryType':                           'category',
            'Census_InternalBatteryNumberOfCharges':                'float64',  # was 'float32'
            'Census_OSVersion':                                     'category',
            'Census_OSArchitecture':                                'category',
            'Census_OSBranch':                                      'category',
            'Census_OSBuildNumber':                                 'int16',
            'Census_OSBuildRevision':                               'int32',
            'Census_OSEdition':                                     'category',
            'Census_OSSkuName':                                     'category',
            'Census_OSInstallTypeName':                             'category',
            'Census_OSInstallLanguageIdentifier':                   'float16',
            'Census_OSUILocaleIdentifier':                          'int16',
            'Census_OSWUAutoUpdateOptionsName':                     'category',
            'Census_IsPortableOperatingSystem':                     'int8',
            'Census_GenuineStateName':                              'category',
            'Census_ActivationChannel':                             'category',
            'Census_IsFlightingInternal':                           'float16',
            'Census_IsFlightsDisabled':                             'float16',
            'Census_FlightRing':                                    'category',
            'Census_ThresholdOptIn':                                'float16',
            'Census_FirmwareManufacturerIdentifier':                'float16',
            'Census_FirmwareVersionIdentifier':                     'float32',
            'Census_IsSecureBootEnabled':                           'int8',
            'Census_IsWIMBootEnabled':                              'float16',
            'Census_IsVirtualDevice':                               'float16',
            'Census_IsTouchEnabled':                                'int8',
            'Census_IsPenCapable':                                  'int8',
            'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
            'Wdft_IsGamer':                                         'float16',
            'Wdft_RegionIdentifier':                                'float16',
            'HasDetections':                                        'float32',
        }
        self.file_name = 'malware_train.csv'
        self.scaler = StandardScaler()
        self.remove_cols = []

    def clean(self, test_data):
        test_data.drop(columns=self.remove_cols, inplace=True)
        # clean up NaN values
        for column in test_data.columns:
            test_data[column].fillna(test_data[column].mode()[0], inplace=True)

        # encode string values
        for col in test_data.columns:
            test_data[col] = self.le.fit_transform(test_data[col])
        return test_data

    def _clean(self, df):

        # determine skewedness
        skew = pd.DataFrame([{'column': c, 'uniq': df[c].nunique(), 'skew': df[c].value_counts(
            normalize=True).values[0] * 100} for c in df.columns])
        skew = skew.sort_values('skew', ascending=False)
        self.remove_cols.extend(skew[(skew['skew'] > 90)].column.tolist())

        # determine null columns
        total = df.isnull().sum().sort_values(ascending=False)
        percent = (df.isnull().sum()/df.isnull().count()
                   * 100).sort_values(ascending=False)
        null_cols = pd.concat([total, percent], axis=1,
                              keys=['Total', 'Percent'])
        self.remove_cols.extend(
            null_cols[(null_cols['Percent'] > 5)].index.tolist())

        self.remove_cols.extend(['Census_ProcessorClass', 'Census_IsWIMBootEnabled', 'IsBeta', 'Census_IsFlightsDisabled', 'Census_IsFlightingInternal', 'AutoSampleOptIn', 'Census_ThresholdOptIn', 'SMode',
                                 'Census_IsPortableOperatingSystem', 'PuaMode', 'Census_DeviceFamily', 'UacLuaenable', 'Census_IsVirtualDevice', 'Platform', 'Census_OSSkuName', 'Census_OSInstallLanguageIdentifier', 'Processor'])
        print(self.remove_cols)
        df.drop(columns=self.remove_cols, inplace=True)
        # print(self.null_cols)
        # clean up NaN values
        for column in df.columns:
            df[column].fillna(df[column].mode()[0], inplace=True)

        # encode string values
        self.le = LabelEncoder()
        for col in df.columns:
            df[col] = self.le.fit_transform(df[col])
        # plt.matshow(df.corr())

       # set index to be the machine IDs
        # df.set_index('MachineIdentifier', inplace=True)
        return df

    # trains a model, you can access the malware_train.csv file for training your model
    def train(self):

        # read in csv into dataframe
        df = pd.read_csv(self.file_name, dtype=self.dtypes)
        df = self._clean(df)

        # prediction column
        y_train = df['HasDetections']
        # feature columns
        x_train = df.drop('HasDetections', 1)
        x_train[x_train.columns] = self.scaler.fit_transform(
            x_train[x_train.columns])
        # self.pca(x_train, y_train)

        # training
        # self.clf = RandomForestClassifier(max_depth=25, n_jobs=100)
        # self.clf = AdaBoostClassifier()
        # self.clf = GradientBoostingClassifier()
        # self.clf.fit(x_train, y_train)
        print('Training finished.')

        self.clf = Sequential()

        # 80#################################
        # # Adding the input layer and the first hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu', input_dim=len(x_train.columns)))
        # # Adding the second hidden layer
        # self.clf.add(Dense(output_dim=20, init='uniform', activation='relu'))
        # # fourth hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu'))

        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu'))
        # # fifth hidden layer
        # self.clf.add(Dense(output_dim=15, init='uniform', activation='softmax'))
        # # Adding the output layer
        # self.clf.add(Dense(output_dim=1, init='uniform', activation='sigmoid'))
        # # Compiling Neural Network
        # self.clf.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

        # 80#################################
        # Adding the input layer and the first hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu', input_dim=len(x_train.columns)))
        # # Adding the second hidden layer
        # self.clf.add(Dense(output_dim=20, init='uniform', activation='tanh'))
        # # fourth hidden layer
        # self.clf.add(Dense(output_dim=30, init='uniform', activation='relu'))

        # self.clf.add(Dense(output_dim=30, init='uniform', activation='tanh'))
        # # fifth hidden layer
        # self.clf.add(Dense(output_dim=15, init='uniform', activation='softmax'))
        # # Adding the output layer
        # self.clf.add(Dense(output_dim=1, init='uniform', activation='sigmoid'))
        # # Compiling Neural Network
        # self.clf.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

        # 25###################################
        # Adding the input layer and the first hidden layer
        self.clf.add(Dense(output_dim=20, init='uniform',
                           activation='relu', input_dim=len(x_train.columns)))
        # Adding the second hidden layer
        self.clf.add(Dense(output_dim=10, init='uniform', activation='relu'))
        # Adding the output layer
        self.clf.add(Dense(output_dim=1, init='uniform', activation='sigmoid'))
        # Compiling Neural Network
        self.clf.compile(optimizer='adam',
                         loss='binary_crossentropy', metrics=['accuracy'])

        # Fitting our model
        history = self.clf.fit(
            x_train, y_train, validation_split=0.3, batch_size=100, nb_epoch=20)
        print('Training finished.')
    # predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
    # This function must return the predicted probabilities for the test machines

    def predict_probablities(self, test_data):
        print('Predict malware')
        test_data = self.clean(test_data)
        test_data[test_data.columns] = self.scaler.fit_transform(
            test_data[test_data.columns])
        predictions = self.clf.predict(test_data)
        return predictions


# calls the train function and saves the model_file
# # donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()

# dm = MalwareDetectionModel()
