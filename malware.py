import warnings
import numpy as np
import pandas as pd
import pickle
import dill
import random
from sklearn.naive_bayes import MultinomialNB
from sklearn.model_selection import cross_val_score
from sklearn.tree import DecisionTreeClassifier

# Donot modify the method signatures and return _dtypes
# you can include additional functions of your choice

class MalwareDetectionModel:

    def __init__(self):
        self.dtypes= {}
        self._dtypes = {
            'MachineIdentifier': 'object',
            'ProductName': 'category',
            'EngineVersion': 'category',
            'AppVersion': 'category',
            'AvSigVersion': 'category',
            'IsBeta': 'bool',
            'RtpStateBitfield': 'float32',
            'IsSxsPassiveMode': 'bool',
            'DefaultBrowsersIdentifier': 'float32',
            'AVProductStatesIdentifier': 'object',
            'AVProductsInstalled': 'int32',
            'AVProductsEnabled': 'int32',
            'HasTpm': 'bool',
            'CountryIdentifier': 'category',
            'CityIdentifier': 'category',
            'OrganizationIdentifier': 'category',
            'GeoNameIdentifier': 'category',
            'LocaleEnglishNameIdentifier': 'category',
            'Platform': 'category',
            'Processor': 'category',
            'OsVer': 'category',
            'OsBuild': 'category',
            'OsSuite': 'category',
            'OsPlatformSubRelease': 'category',
            'OsBuildLab': 'category',
            'SkuEdition': 'category',
            'IsProtected': 'bool',
            'AutoSampleOptIn': 'bool',
            'PuaMode': 'category',
            'SMode': 'bool',
            'IeVerIdentifier': 'category',
            'SmartScreen': 'category',
            'Firewall': 'bool',
            'UacLuaenable': 'category',
            'Census_MDC2FormFactor': 'category',
            'Census_DeviceFamily': 'category',
            'Census_OEMNameIdentifier': 'category',
            'Census_OEMModelIdentifier': 'category',
            'Census_ProcessorCoreCount': 'int32',
            'Census_ProcessorManufacturerIdentifier': 'category',
            'Census_ProcessorModelIdentifier': 'category',
            'Census_ProcessorClass': 'category',
            'Census_PrimaryDiskTotalCapacity': 'float32',
            'Census_PrimaryDiskTypeName': 'category',
            'Census_SystemVolumeTotalCapacity': 'float32',
            'Census_HasOpticalDiskDrive': 'bool',
            'Census_TotalPhysicalRAM': 'float32',
            'Census_ChassisTypeName': 'category',
            'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'float32',
            'Census_InternalPrimaryDisplayResolutionHorizontal': 'float32',
            'Census_InternalPrimaryDisplayResolutionVertical': 'float32',
            'Census_PowerPlatformRoleName': 'category',
            'Census_InternalBatteryType': 'category',
            'Census_InternalBatteryNumberOfCharges': 'float32',
            'Census_OSVersion': 'category',
            'Census_OSArchitecture': 'category',
            'Census_OSBranch': 'category',
            'Census_OSBuildNumber': 'category',
            'Census_OSBuildRevision': 'category',
            'Census_OSEdition': 'category',
            'Census_OSSkuName': 'category',
            'Census_OSInstallTypeName': 'category',
            'Census_OSInstallLanguageIdentifier': 'category',
            'Census_OSUILocaleIdentifier': 'category',
            'Census_OSWUAutoUpdateOptionsName': 'category',
            'Census_IsPortableOperatingSystem': 'bool',
            'Census_GenuineStateName': 'category',
            'Census_ActivationChannel': 'category',
            'Census_IsFlightingInternal': 'bool',
            'Census_IsFlightsDisabled': 'bool',
            'Census_FlightRing': 'category',
            'Census_ThresholdOptIn': 'bool',
            'Census_FirmwareManufacturerIdentifier': 'category',
            'Census_FirmwareVersionIdentifier': 'category',
            'Census_IsSecureBootEnabled': 'bool',
            'Census_IsWIMBootEnabled': 'bool',
            'Census_IsVirtualDevice': 'bool',
            'Census_IsTouchEnabled': 'bool',
            'Census_IsPenCapable': 'bool',
            'Census_IsAlwaysOnAlwaysConnectedCapable': 'bool',
            'Wdft_IsGamer': 'bool',
            'Wdft_RegionIdentifier': 'category',
            'HasDetections': 'bool',
        }
        self.file_name = 'malware_train.csv'
        self.clf = DecisionTreeClassifier()
        

    def _clean(self, df):
        # clean up NaN values
        for column in df.columns:
            df[column] = df[column].fillna(0)

        if 'HasDetections' in df.columns:
            # assign _dtypes
            df = df.astype(self._dtypes)

            # shuffling data
            all_ids = np.arange(len(df))
            random.shuffle(all_ids)
        else:
            __dtypes = self._dtypes.pop('HasDetections', None)
            df = df.astype(__dtypes)
    

        # mapping categorical data to ints
        cat_columns = df.select_dtypes(['category']).columns
        df[cat_columns] = df[cat_columns].apply(lambda column: column.cat.codes)

       # set index to be the machine IDs 
        df.set_index('MachineIdentifier', inplace=True)

        return df


    # trains a model, you can access the malware_train.csv file for training your model
    def train(self):
        # read in csv into dataframe
        df = pd.read_csv(self.file_name, low_memory=False)
        
        df = self._clean(df)

        # prediction column
        y_train = df['HasDetections']
        # feature columns
        x_train = df.drop('HasDetections', 1)
        # training
        self.clf = DecisionTreeClassifier(max_depth=20)
        self.clf.fit(x_train, y_train)
        # scores = cross_val_score(self.clf, x_train, y_train, cv=10, verbose=2, n_jobs=-1)
        scores = cross_val_score(self.clf, x_train, y_train, cv=10, n_jobs=-1)
        print(scores.mean())

    # predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
    # This function must return the predicted probabilities for the test machines
    def predict_probablities(self, test_data):
        print('Predict malware')
        test_data = self._clean(test_data)
        predictions = self.clf.predict(test_data)
        return predictions


# calls the train function and saves the model_file
# # donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()

# dm = MalwareDetectionModel()
